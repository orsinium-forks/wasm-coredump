use crate::repl::Context;
use crate::{memory, BoxError};
use colored::Colorize;

pub(crate) fn backtrace<'a>(
    ctx: &Context<'a>,
    thread: &wasm_coredump_types::CoreStack,
) -> Result<(), BoxError> {
    let mut i = thread.frames.len();
    for frame in &thread.frames {
        i -= 1;
        if let Some(selected_frame) = &ctx.selected_frame {
            if selected_frame.code_offset == frame.code_offset {
                print!("#{}*\t", i);
            } else {
                print!("#{}\t", i);
            }
        } else {
            print!("#{}\t", i);
        }

        print_frame(ctx, &frame)?;
    }

    Ok(())
}

pub(crate) fn print_frame<'a>(
    ctx: &Context<'a>,
    frame: &wasm_coredump_types::StackFrame,
) -> Result<(), BoxError> {
    let coredump = ctx.coredump.as_ref().ok_or("no coredump present")?;
    let binary_name = ctx
        .source
        .get_func_name(frame.code_offset)
        .unwrap_or_else(|| "unknown".to_string());

    if let Some(func) = ctx.ddbug.functions_by_linkage_name.get(&binary_name) {
        let source = format!(
            "{}/{}",
            func.source()
                .directory()
                .unwrap_or_else(|| "<directory not found>"),
            func.source().file().unwrap_or_else(|| "<file not found>")
        );

        let function = {
            let name = func.name().unwrap();

            let params = func
                .details(&ctx.ddbug)
                .parameters()
                .iter()
                .map(|param| {
                    let param_name = if let Some(name) = param.name() {
                        name
                    } else {
                        "???"
                    };

                    // TODO: not always 4 bytes, right?
                    let size_of = 4;

                    let value = if let Ok(addr) = memory::get_param_addr(frame, &func, param) {
                        let bytes = memory::read(&coredump.data, addr, size_of).unwrap();
                        format!("0x{}", hex::encode(&bytes))
                    } else {
                        "???".to_owned()
                    };
                    format!("{}={}", param_name.green(), value)
                })
                .collect::<Vec<String>>()
                .join(", ");

            format!("{} ({})", name.yellow(), params)
        };

        let addr = format!("{:0>6}", frame.code_offset).blue();
        println!("{} as {} at {}", addr, function, source);
    } else {
        // Functions that are generated by Wasi and don't have a source (ie
        // some Wasi transpolines) don't have a mapping in DWARF.
        let addr = format!("{:0>6}", frame.code_offset).blue();
        println!("{} as {} at <no location>", addr, binary_name);
    }

    Ok(())
}

pub(crate) fn select_frame<'a>(
    ctx: &mut Context<'a>,
    frame: &wasm_coredump_types::StackFrame,
) -> Result<(), BoxError> {
    // Clear previous selected scope
    ctx.variables.clear();

    let binary_name = ctx
        .source
        .get_func_name(frame.code_offset)
        .unwrap_or_else(|| "unknown".to_string());

    let func = ctx
        .ddbug
        .functions_by_linkage_name
        .get(&binary_name)
        .ok_or(format!("function {} not found", binary_name))?;

    for param in func.details(&ctx.ddbug).parameters() {
        if let Some(name) = param.name() {
            ctx.variables.insert(name.to_owned(), param.clone());
        }
    }
    Ok(())
}
